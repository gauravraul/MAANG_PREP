# Medium-Difficulty System Design Q&A — Set 6

## 1) Design Multi-Region Active–Active for a Read-Heavy API
**Question:** How would you design an API that serves globally with **active–active** regions?  
**Answer:**  
- **Routing:** Anycast DNS → nearest region; health-based failover.  
- **Data:** Leaderless/replicated store (DynamoDB Global Tables/Cassandra) for eventual consistency; pin **strongly consistent writes** (e.g., payments) to a home region.  
- **Cache:** Regional Redis clusters; cache-aside; versioned objects.  
- **Conflicts:** Last-write-wins with vector clocks or app-level merge.  
- **Gotchas:** Clock skew, write amplification across regions, read-after-write guarantees for critical paths (use read-my-writes via sticky session or quorum reads).

---

## 2) Design a Distributed Cache with Hot-Key Protection
**Question:** How do you design a Redis/Memcached layer that avoids hot-key overloads?  
**Answer:**  
- **Sharding:** Consistent hashing with virtual nodes.  
- **Hot-key controls:** Per-key request coalescing (single-flight), local L1 cache, proactive warming.  
- **Stampede control:** TTL jitter, soft TTL + async refresh, semaphore around misses.  
- **Resilience:** Replica promotion, client-side timeouts/circuit breakers.  
- **Metrics:** Key-level QPS/latency to detect hotspots automatically.

---

## 3) Design an Event-Sourced Order Service
**Question:** How do you design an order domain using **event sourcing**?  
**Answer:**  
- **Model:** Append-only events (Created, ItemAdded, Paid, Shipped).  
- **State:** Materialize **read models** (views) via consumers; rebuild from the log.  
- **Storage:** Immutable log (Kafka) + snapshotting for fast recovery.  
- **Benefits:** Full audit, temporal queries, easy CQRS.  
- **Challenges:** Schema evolution for events, idempotent consumers, rebuilding projections after bugs.

---

## 4) Design a Real-Time Collaborative Whiteboard
**Question:** How would you support dozens of users drawing simultaneously?  
**Answer:**  
- **Sync:** WebSockets; **CRDTs** for shapes/paths to allow peer merges.  
- **Transport:** Binary deltas for strokes; server fan-out by board ID.  
- **Persistence:** Periodic snapshots + event log of ops.  
- **Optimizations:** Rate-limit pointer events, region-based quadtree diffing for partial redraws.  
- **Conflicts:** CRDT tombstones/GC; cursor presence tracked separately.

---

## 5) Design E-commerce Checkout with Idempotency
**Question:** How do you prevent duplicate charges/retries in checkout?  
**Answer:**  
- **Idempotency keys:** Client generates; server stores result keyed by `(key, user)`.  
- **Workflow:** Reserve inventory → authorize payment → finalize order → capture payment.  
- **Consistency:** Outbox pattern to emit events atomically; saga compensations (release stock/refund).  
- **Reliability:** Exactly-once message processing via de-dup store; retry with exponential backoff.

---

## 6) Design an Image Processing Pipeline (thumbs, OCR, moderation)
**Question:** How to process uploads with multiple transforms asynchronously?  
**Answer:**  
- **Flow:** Upload → Object store → Enqueue job(s) → Workers (resize/OCR/moderation) → Write results/metadata → Notify client.  
- **Parallelism:** Fan-out per operation; idempotent job IDs.  
- **Storage:** Variants with deterministic keys (`hash_wxh_format`).  
- **Safety:** Virus scan first; timeouts and dead-letter queues for failures.  
- **Scale:** Auto-scale workers; prioritize small images to keep tail latency low.

---

## 7) Design SSO for Multi-Tenant SaaS (OIDC/SAML)
**Question:** How would you integrate SSO for thousands of tenants?  
**Answer:**  
- **Discovery:** Per-tenant IdP config (OIDC/SAML metadata), domain-based routing (`tenant.example.com`).  
- **Session:** Short-lived JWT access token + refresh token; audience/tenant claims.  
- **Provisioning:** Just-in-time user creation with SCIM optional.  
- **Security:** PKCE, nonce/state checks, role mapping; key rotation (JWKS).  
- **Edge cases:** Clock skew, logout propagation, constraint of group → role mappings.

---

## 8) Design a Reliable Webhook Delivery Service
**Question:** How do you deliver webhooks with retries and ordering guarantees?  
**Answer:**  
- **Queue:** Per-subscriber FIFO queues; backoff with jitter; max-attempts + DLQ.  
- **Signing:** HMAC signatures with timestamp to prevent replays; rotating secrets.  
- **Idempotency:** Event IDs + receiver de-dup.  
- **Ops:** Redelivery UI, selective replays, exponential backoff caps.  
- **Scaling:** Concurrency caps per endpoint to avoid overloading receivers.

---

## 9) Design a Time-Series Monitoring System (alerts at scale)
**Question:** How would you ingest metrics and trigger alerts quickly?  
**Answer:**  
- **Ingest:** Prometheus/OpenTelemetry → remote write to TSDB (Cortex/Thanos/M3).  
- **Storage:** Downsampling & retention tiers (1s → 1m → 5m rollups).  
- **Alerting:** Rule engine evaluates queries per window; silence windows; dedup across replicas.  
- **Reliability:** High-cardinality guardrails, label limits, per-tenant quotas.  
- **Delivery:** Multi-channel notifiers with inhibition and escalation policies.

---

## 10) Design a Cost-Aware Batch Scheduler
**Question:** How do you schedule large batch jobs minimizing cloud cost?  
**Answer:**  
- **Placement:** Spot/preemptible first with checkpointing; fall back to on-demand.  
- **Packing:** Bin-packing by CPU/RAM/GPU; gang scheduling for MPI.  
- **SLAs:** Priority queues; budgets per team; kill/scale policies near deadlines.  
- **Observability:** Per-job cost attribution; predictive scaling from historical runs.  
- **Resilience:** Preemption-aware savepoints; retry on different AZ/instance types.
