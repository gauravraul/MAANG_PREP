# Easy System Design Interview Questions & Answers

---

## Q1: Design a URL Shortener

### Answer:

### Functional Requirements:
- Convert long URLs to short URLs
- Redirect to original URL
- Handle high traffic
- Analytics (optional)

### Non-Functional Requirements:
- Low latency
- High availability
- Scalability

### Architecture:
Client → Load Balancer → API Server  
API Server → Redis Cache  
API Server → Database  

### Components:
- API Service
- Cache (Redis)
- Database (SQL/NoSQL)
- Load Balancer
- ID Generator

### URL Generation Strategy:
- Base62 encoding
- Auto-increment ID or UUID
- Collision handling with retries

### Scaling:
- Redis for hot URLs
- DB replication
- Horizontal scaling

### Failure Handling:
- Cache fallback to DB
- Logging & monitoring
- Retry mechanism

---

## Q2: Design an E-Commerce System

### Answer:

### Functional Requirements:
- Product listing
- Cart
- Checkout
- Order history

### Architecture:
Frontend → API Gateway → Microservices  
Services → Database & Payment Gateway  

### Services:
- User Service
- Product Service
- Cart Service
- Order Service
- Payment Service

### Databases:
- Product DB
- User DB
- Orders DB

### Scaling:
- Cache products
- CDN for images
- Partition orders table

### Failure Handling:
- Retry payments
- Rollback inventory
- Compensation logic

---

## Q3: Design a Chat Application

### Answer:

### Requirements:
- One-to-one messaging
- Online presence
- Chat history

### Architecture:
Client → WebSocket Server → Message Queue  
Queue → Storage  

### Components:
- Presence Service
- Message Queue
- WebSocket Server
- Database

### Datastore:
- NoSQL DB
- Indexed by user_id

### Scaling:
- Shard users
- Partition chats by date

### Reliability:
- Message retry
- Acknowledgements
- Offline sync

---

## Q4: Design a News Feed System

### Answer:

### Requirements:
- Feed generation
- Ranking
- Real-time updates

### Feed Models:
Push Model – Pre-compute feed  
Pull Model – Generate on demand  
Hybrid Model – Combination

### Architecture:
Post Service → Feed Generator → Redis  
Redis → API → Client

### Storage:
- Posts DB
- Redis for feeds

### Scaling:
- Cache feeds
- Fan-out services
- Sharded timelines

---

## Q5: Design User Authentication System

### Answer:

### Features:
- Signup
- Login
- Logout
- Reset password

### Architecture:
Client → Auth Service → User DB  
Auth Service → Redis Cache  

### Security:
- Hashed passwords
- JWT tokens
- Rate limiting
- CAPTCHA

### Flow:
- Validate user
- Generate token
- Session management

---

## Q6: Design File Storage System

### Answer:

### Requirements:
- Upload
- Download
- Versioning
- Access control

### Architecture:
Client → Metadata Service → DB  
Client → Object Storage  

### Techniques:
- Chunk uploads
- Compression
- Deduplication

### Scaling:
- CDN for downloads
- Parallel uploads

---

## Q7: Design a Rate Limiter

### Answer:

### Algorithms:
- Token Bucket
- Fixed Window
- Sliding Window

### Architecture:
Client → Gateway → Redis Counter

### Rules:
- Per IP
- Per user
- Per API

### Scaling:
- Redis cluster
- Sharded counters

---

## Q8: Design API Gateway

### Answer:

### Responsibilities:
- Authentication
- Load balancing
- Throttling
- Routing

### Architecture:
Client → API Gateway → Services

### Tools:
- Nginx
- Kong
- AWS Gateway

---

## Q9: Design Logging System

### Answer:

### Flow:
Application → Log Agent → Kafka  
Kafka → Storage → Dashboard  

### Storage:
- Elasticsearch
- Cloud storage

### Visualization:
- Kibana
- Grafana

---

## Q10: Design Notification System

### Answer:

### Types:
- Email
- SMS
- Push

### Architecture:
Request → Queue → Worker → Provider

### Features:
- Retry mechanism
- Dead Letter Queue
- Failure alerting

---

## Q11: Design Search System

### Answer:

### Flow:
Data Ingestion → Indexing → Query Engine

### Components:
- Search API
- Index store
- Ranking engine

### Storage:
- Elasticsearch
- Redis cache

### Scaling:
- shards
- replication

---

## Q12: Design Analytics System

### Answer:

### Pipeline:
Events → Queue → Processing → Storage → Dashboard

### Components:
- Kafka
- Spark / Flink
- Data warehouse

### Handling:
- Late events
- Deduplication
- Aggregation

---

## Q13: Design Payment System

### Answer:

### Architecture:
Client → Payments API → Bank Gateway

### Features:
- Idempotency
- Retry logic
- Reconciliation

### Failure Handling:
- Rollback orders
- Alert system

---

## Q14: Design Recommendation System

### Answer:

### Data:
- User behavior
- Item features

### Architecture:
Data → Model → API → Client

### Types:
- Collaborative filtering
- Content-based

### Scaling:
- Precompute recommendations
- Cache

---

## Q15: Design Social Media Posting System

### Answer:

### Architecture:
User → Post Service → Feed Generator → Cache

### Storage:
- Media in object store
- Metadata in DB

### Scaling:
- Fanout services
- Feed sharding

---

# Interview Answer Template

1. Clarify requirements  
2. Define architecture  
3. Identify components  
4. Database design  
5. Scaling  
6. Failures  
7. Security  
8. Trade-offs  
9. Optimizations  
10. Monitoring
