# System Design Interview Q&A – Set 18 (Lightning Rounds / 2-Minute Answers)

> ⚡ Used in **rapid-fire interviews** where you must give a **clear, correct, minimal answer** fast.

---

## Q1: How do you prevent cache stampede?

### Answer:
- Use **request coalescing** (single flight per key)
- Add **soft TTL** + serve stale while refreshing
- Rate-limit DB fallback
- Pre-warm hot keys
- Circuit breaker on DB

---

## Q2: How do you design idempotent APIs?

### Answer:
- Require **idempotency key**
- Store key → response/result
- On retry, return stored result
- Make state transitions compare-and-set
- Expire idempotency records safely

---

## Q3: How do you handle duplicate messages in queues?

### Answer:
- Assume **at-least-once delivery**
- Deduplicate by `message_id`
- Track processed IDs with TTL
- Make consumers idempotent
- Use exactly-once effect, not delivery

---

## Q4: How do you ensure read-your-writes in an eventually consistent system?

### Answer:
- Client affinity to home replica
- Version tokens / session vectors
- Reads wait until replica ≥ client version
- Buffer writes locally during partitions

---

## Q5: How do you design a rate limiter?

### Answer:
- Token bucket or sliding window
- Enforce at API gateway
- Store counters in Redis
- Shard by key
- Local fallback with approximate limits

---

## Q6: How do you handle hot partitions?

### Answer:
- Add **randomized suffix** to keys
- Split hot shard dynamically
- Cache aggressively
- Use async writes + batching
- Apply per-key throttling

---

## Q7: How do you design pagination on changing data?

### Answer:
- Use **cursor-based pagination**
- Include snapshot/version token
- Avoid OFFSET
- Stable sort key (time + id)

---

## Q8: How do you design safe schema migrations?

### Answer:
- Backward-compatible first
- Dual-read / dual-write
- Lazy backfill
- Feature-flag schema usage
- Rollback-safe at every step

---

## Q9: How do you prevent split-brain?

### Answer:
- Use quorum-based consensus
- Leader steps down without majority
- Fencing tokens
- Never rely on clocks alone

---

## Q10: How do you detect and handle node failure?

### Answer:
- Heartbeats
- Suspicion timeouts
- Quorum confirmation
- Graceful degradation
- Automatic recovery + rebalancing

---

## Q11: How do you design distributed locks?

### Answer:
- Use consensus-backed lease
- Return fencing token
- TTL for liveness
- Resource validates token
- Avoid long-held locks

---

## Q12: How do you ensure exactly-once processing?

### Answer:
- At-least-once delivery
- Idempotent processing
- Deduplication store
- Atomic state transitions

---

## Q13: How do you design a leaderboard?

### Answer:
- Sorted sets
- Shard by game/region
- Periodic snapshots
- CRDT counters for merges

---

## Q14: How do you design file uploads at scale?

### Answer:
- Chunked uploads
- Resume via chunk IDs
- Pre-signed URLs
- Server-side assembly

---

## Q15: How do you design feature flags?

### Answer:
- Central control plane
- SDK with cache
- % rollout via hashing
- Kill switch
- Metrics-driven rollback

---

## Q16: How do you ensure global uniqueness?

### Answer:
- UUIDv7 / ULID
- Snowflake IDs
- Region + time + counter
- Avoid central bottleneck

---

## Q17: How do you handle clock skew?

### Answer:
- Prefer logical clocks
- Use monotonic clocks for durations
- Avoid absolute timestamps for ordering
- Sync offsets periodically

---

## Q18: How do you design search autocomplete?

### Answer:
- Trie or prefix index
- Top-K per node
- Cache in memory
- Batch rebuild rankings

---

## Q19: How do you design real-time notifications?

### Answer:
- Queue + workers
- Retry + DLQ
- Multi-channel fallback
- In-app inbox for reliability

---

## Q20: How do you make systems observable?

### Answer:
- Metrics (RED/USE)
- Structured logs
- Distributed tracing
