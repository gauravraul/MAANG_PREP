# Medium-Difficulty System Design Q&A — Set 5

## 1) Design a Real-Time Ads Bidding Platform (RTB)
**Question:** How would you design a low-latency RTB system that bids on ad impressions in ~50–100 ms?  
**Answer:**  
- **Flow:** SSP sends bid request → Edge bidder (per region) → Feature fetch (user/device/context) → Model score → Bid response.  
- **Infra:** Anycast → regional bidders; in-memory feature cache; model served via gRPC with warm replicas.  
- **Data:** Kafka for logs; offline training on impression/click/conversion data; online metrics in ClickHouse/Druid.  
- **Key points:** Hard timeouts (e.g., 40 ms budget), probabilistic fallbacks when features missing, frequency capping in Redis, pacing per campaign.  
- **Challenges:** Strict latency SLO, budget pacing, fraud filtering, multi-tenant isolation.

---

## 2) Design an A/B Testing & Experimentation Platform
**Question:** How to randomize users into variants, ensure consistency, and measure lift?  
**Answer:**  
- **Assignment:** Deterministic hashing of `(user_id, experiment_id)` → bucket → variant; sticky assignment via cookie/user-id.  
- **Storage:** Experiment config service; exposure logs to Kafka; metrics computed by batch/stream (guardrails + CUPED).  
- **Serving:** Client/server SDKs pull config snapshots; kill-switch and % rollouts.  
- **Challenges:** Mutual exclusion, overlapping tests, metric drift, north-star vs guardrail metrics, delayed conversions.

---

## 3) Design a Multi-Tenant SaaS with Strong Isolation
**Question:** How to serve thousands of tenants with data isolation and shared infrastructure?  
**Answer:**  
- **Isolation models:** Shared DB with row-level tenant keys; schema-per-tenant; DB-per-tenant (for VIPs).  
- **Control plane:** Tenant lifecycle, quota, billing, config.  
- **Data plane:** Namespaced queues/caches; per-tenant rate limits; encryption-at-rest with per-tenant DEKs (wrapped by KMS).  
- **Observability:** Tenant-scoped dashboards, noisy-neighbor detection.  
- **Challenges:** Hot tenants, schema evolution, compliant data export/delete.

---

## 4) Design a Distributed Cron/Scheduler Service
**Question:** How to run millions of scheduled jobs reliably across regions?  
**Answer:**  
- **Model:** Job spec `{when, cron, payload, retry, ttl}` stored in strongly consistent store.  
- **Execution:** Leader election per shard (e.g., via etcd/Consul); workers claim due jobs (optimistic locking).  
- **Durability:** Idempotency keys; exactly-once via outbox + de-dup; dead-letter queues.  
- **Scaling:** Time-bucket sharding; priority queues; jitter to avoid thundering herds.  
- **Challenges:** Clock skew, daylight saving time, retries vs duplicates.

---

## 5) Design a Map Tiles Service
**Question:** How to serve slippy map tiles at scale?  
**Answer:**  
- **Prep:** Pre-render raster/Vector tiles (z/x/y) from OSM; store in object storage; CDN front.  
- **Online:** Edge cache keyed by `{z}/{x}/{y}` + style/version; support HTTP range for vector tiles.  
- **Updates:** Delta rebuilds for hot regions; background tile regeneration pipeline.  
- **Challenges:** Cache invalidation on data updates, tile seams artifacts, zoom-level storage explosion.

---

## 6) Design a Feature Store for ML (Online + Offline)
**Question:** How to serve consistent features to training and prediction?  
**Answer:**  
- **Offline:** Batch compute to Parquet/Delta; backfills with versioned snapshots.  
- **Online:** Materialize subset to low-latency KV (Redis/DynamoDB); TTL and freshness policies.  
- **Consistency:** Same transformation logic (dbt/Spark) with registries; point-in-time joins to avoid leakage.  
- **Challenges:** Late events, schema/versioning, backfill cost, online/offline skew.

---

## 7) Design a Web Crawler & Indexer
**Question:** How to crawl the web politely and build a searchable index?  
**Answer:**  
- **Crawl:** Frontier priority queue; robots.txt & politeness delays; dedupe via URL canonicalization + content hashes.  
- **Parse:** Extract text/links; language detection; store snapshots in object store.  
- **Index:** Inverted index (Elasticsearch/OpenSearch) with shard/replicas; ranking with BM25 + embeddings (optional).  
- **Challenges:** Infinite spaces (calendars), traps, duplicate content, change detection.

---

## 8) Design a Fraud Detection Stream (Payments)
**Question:** How to score transactions in <100 ms and adapt to new fraud patterns?  
**Answer:**  
- **Online path:** API → feature lookup (device history, velocity, geo-IP) → rules engine + ML model → decision (allow/challenge/deny).  
- **Data:** Stream all outcomes to Kafka; label store; feedback loop for retraining.  
- **Ops:** Shadow deployments for new models; thresholds per merchant; case management UI.  
- **Challenges:** Adversarial drift, latency budget, false positives vs chargeback risk.

---

## 9) Design a Schema Registry & Contract Enforcement
**Question:** How to keep event schemas compatible across microservices?  
**Answer:**  
- **Core:** Central registry (Avro/Protobuf/JSON Schema) with versioning; compatibility modes (backward/forward/full).  
- **Gates:** CI plugins to check schema diffs; producer-side validation; consumer alerts on breaking changes.  
- **Runtime:** Schema IDs embedded in messages; lazy fetch + cache on clients.  
- **Challenges:** Multi-language codegen, deprecation lifecycle, evolving enums.

---

## 10) Design a Workflow Orchestrator with Sagas
**Question:** How to coordinate multi-step, cross-service transactions without 2PC?  
**Answer:**  
- **Pattern:** Saga with steps + compensating actions; persisted state machine (orchestration) or event choreography.  
- **Infra:** Durable command bus (Kafka/SQS), idempotent handlers, outbox pattern to avoid dual-write issues.  
- **Features:** Timeouts, retries, DLQs, observability of saga state, manual intervention hooks.  
- **Challenges:** Exactly-once semantics, partial failures, compensations that aren’t perfectly reversible.
