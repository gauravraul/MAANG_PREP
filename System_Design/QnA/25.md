# System Design Interview Q&A – Set 17 (Design X but REMOVE a Critical Subsystem)

> These questions test whether you understand **why** a component exists,  
> not just **how** to use it.

---

## Q1: Design a Distributed Database — BUT you are NOT allowed to use consensus (Raft/Paxos)

### Answer:

### Lost Capability:
- No global strong consistency
- No single agreed ordering of writes

### New Guarantees:
- Eventual consistency
- Convergence
- No coordination on write path

### Strategy:

1. **Multi-Master Writes**
   - All nodes accept writes independently
   - Writes tagged with:
     - node_id
     - logical timestamp (Lamport / vector clock)

2. **Conflict Resolution**
   - Deterministic merge:
     - Last-write-wins (timestamp + node_id)
     - OR CRDT-based merge (preferred)

3. **Replication**
   - Async gossip or stream replication
   - Anti-entropy background repair

4. **Client Guarantees**
   - Session guarantees:
     - read-your-writes
     - monotonic reads

### Result:
- Highly available
- Partition tolerant
- No strict serializability
- Think Dynamo / Cassandra model

---

## Q2: Design a Cache System — BUT you cannot evict data (no LRU/LFU/TTL)

### Answer:

### Problem:
- Memory grows unbounded

### Strategy:

1. **Capacity Partitioning**
   - Divide cache memory by:
     - tenant
     - feature
     - priority class

2. **Admission Control**
   - Not all data is cached
   - Use:
     - bloom filter
     - frequency sketch
   - Cache only items above access threshold

3. **Cache as Hint**
   - Cache is best-effort
   - DB is always source of truth

4. **Manual Reclamation**
   - Background job:
     - scans cold segments
     - rewrites cache (logical eviction via rebuild)

### Insight:
- Eviction replaced by **selective admission**
- Similar to TinyLFU philosophy

---

## Q3: Design a Payment System — BUT transactions are NOT allowed

### Answer:

### Lost Capability:
- Atomic multi-step updates

### Strategy:

1. **State Machine**
   - Explicit states:
     - INIT
     - AUTHORIZED
     - CAPTURED
     - SETTLED
     - FAILED

2. **Idempotent Transitions**
   - Each transition:
     - compare-and-set
     - guarded by current state

3. **Outbox Pattern**
   - Persist intent first
   - Then trigger side effects (emails, ledger updates)

4. **Reconciliation Jobs**
   - Periodic scan:
     - incomplete states
     - retry or compensate

### Result:
- Eventual consistency
- Strong correctness via state discipline

---

## Q4: Design a Global Messaging System — BUT you cannot guarantee message ordering

### Answer:

### Lost Capability:
- FIFO or total order

### Strategy:

1. **Causal Metadata**
   - Attach:
     - vector clocks
     - causal IDs

2. **Application-Level Ordering**
   - Consumers reorder when needed
   - Or treat messages as independent events

3. **Idempotency**
   - All messages must be idempotent
   - Deduplicate by message_id

4. **User Experience**
   - UI groups by:
     - logical conversation
     - timestamps (best effort)

### Result:
- High throughput
- Simpler infra
- Ordering handled at edge

---

## Q5: Design a Search System — BUT you cannot pre-build indexes

### Answer:

### Lost Capability:
- Fast random access via inverted index

### Strategy:

1. **Scan-Based Search**
   - Partition documents by topic / shard
   - Parallel scan across shards

2. **Pre-Filters**
   - Metadata filters:
     - time range
     - category
   - Reduce scan scope

3. **Caching**
   - Cache popular query results
   - Cache partial scans

4. **Asynchronous Refinement**
   - Return coarse results first
   - Improve results progressively

### Result:
- Slower worst-case
- Works for small/medium datasets
- Useful for exploratory analytics

---

## Q6: Design a Distributed Lock — BUT clocks are completely unreliable

### Answer:

### Lost Capability:
- TTL-based leases
- Time-based expiry

### Strategy:

1. **Consensus-Based Lock**
   - Majority vote determines lock owner
   - Lock held only while majority reachable

2. **Fencing Tokens**
   - Each lock acquisition returns monotonic token
   - Resource checks token validity

3. **Failure Handling**
   - If owner loses quorum → lock invalid
   - No reliance on time

### Result:
- Strong safety
- Lower availability during partitions

---

## Q7: Design a Notification System — BUT you cannot retry failed deliveries

### Answer:

### Lost Capability:
- Reliability via retries

### Strategy:

1. **Multi-Channel Delivery**
   - Send via:
     - email
     - SMS
     - push
   - Single attempt per channel

2. **In-App Inbox**
   - Always record notification in app
   - Delivery channels become optional UX enhancement

3. **Delivery Transparency**
   - Expose status:
     - sent
     - failed
     - unknown

### Result:
- User trust preserved
- System remains simple

---

## Q8: Design a Feature Flag System — BUT clients can NEVER call home (offline-only)

### Answer:

### Lost Capability:
- Real-time updates

### Strategy:

1. **Pre-Baked Rules**
   - Flags encoded with:
     - device attributes
     - build version
     - expiration date

2. **Fail-Safe Defaults**
   - Risky features default OFF
   - Safe features default ON

3. **Time-Bound Flags**
   - Flags auto-expire
   - Forces new release if needed

### Result:
- No dynamic kill-switch
- Safer offline behavior

---

## Q9: Design an Analytics System — BUT raw events CANNOT be stored (privacy)

### Answer:

### Lost Capability:
- Reprocessing
- Backfills

### Strategy:

1. **Streaming Aggregation**
   - Compute aggregates on ingest
   - Discard raw events immediately

2. **Sketches**
   - HyperLogLog (unique counts)
   - Count-Min Sketch (frequency)
   - TDigest (percentiles)

3. **Differential Privacy**
   - Noise injected at aggregation

### Result:
- Strong privacy
- Limited flexibility
- Real-time insights only

---

## Q10: Design a Distributed System — BUT you cannot rely on the network

### Answer:

### Interpretation:
- Network is slow, flaky, unpredictable

### Strategy:

1. **Local-First Design**
   - Everything works locally
   - Network used only for sync

2. **Operation Logs**
   - Append local ops
   - Sync opportunistically

3. **Conflict Resolution**
   - CRDTs
   - Last-write-wins where acceptable

4. **User Experience**
   - Immediate local feedback
   - Sync status visible

### Result:
- Offline-first systems
- High resilience
- Eventual global convergence

---

# Interview Meta-Skill Tested in Set 17

These questions test:

1. Do you understand **why** systems use:
   - consensus
   - transactions
   - ordering
   - indexes
   - retries
2. Can you replace a missing guarantee with:
   - idempotency
   - state machines
   - CRDTs
   - compensation
3. Can you clearly state:
   - what is LOST
   - what is KEPT
   - what is DEGRADED

If you can do this calmly → you are operating at **Staff / Principal / Architect** level.
